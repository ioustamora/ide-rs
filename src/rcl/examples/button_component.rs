//! Example Button Component using ComponentMetadata derive macro
//!
//! This example demonstrates how to use the derive macro to automatically
//! generate component metadata and property schemas.

use crate::rcl::component_registry::ComponentRegistry;
use crate::rcl::derive_macros::derive_component_metadata;
use proc_macro2::TokenStream;
use syn::parse_quote;

/// Example Button component with derive macro
/// 
/// This struct demonstrates the usage of the ComponentMetadata derive macro
/// with various property types and attributes.
/// 
/// ```
/// #[derive(ComponentMetadata)]
/// #[component(
///     name = "Button",
///     display_name = "Button",
///     description = "A clickable button component",
///     category = "Input",
///     version = "1.0.0"
/// )]
/// struct Button {
///     #[property(default = "Click me", description = "Button text")]
///     text: String,
///     
///     #[property(default = true, description = "Whether the button is enabled")]
///     enabled: bool,
///     
///     #[property(advanced = true, description = "Custom CSS classes")]
///     classes: Vec<String>,
///     
///     #[property(default = 16, description = "Font size in pixels")]
///     font_size: i32,
/// }
/// ```
pub struct Button {
    pub text: String,
    pub enabled: bool,
    pub classes: Vec<String>,
    pub font_size: i32,
}

impl Button {
    pub fn new() -> Self {
        Self {
            text: "Click me".to_string(),
            enabled: true,
            classes: Vec::new(),
            font_size: 16,
        }
    }
}

/// Example demonstration of manual macro invocation
/// (In practice, this would be done by the actual derive macro)
pub fn generate_button_metadata() -> proc_macro2::TokenStream {
    let input: syn::DeriveInput = parse_quote! {
        #[component(
            name = "Button",
            display_name = "Button", 
            description = "A clickable button component",
            category = "Input",
            version = "1.0.0"
        )]
        struct Button {
            #[property(default = "Click me", description = "Button text")]
            text: String,
            
            #[property(default = true, description = "Whether the button is enabled")]
            enabled: bool,
            
            #[property(advanced = true, description = "Custom CSS classes")]
            classes: Vec<String>,
            
            #[property(default = 16, description = "Font size in pixels")]
            font_size: i32,
        }
    };
    
    derive_component_metadata(input.into())
}

/// Manual implementation of what the derive macro would generate
/// This shows exactly what code would be produced by the macro
impl Button {
    /// Get component metadata (this would be generated by derive macro)
    pub fn component_metadata() -> crate::rcl::component_registry::ComponentMetadata {
        use std::collections::HashMap;
        use crate::rcl::component_registry::*;
        
        let mut properties = HashMap::new();
        
        // text property
        properties.insert(
            "text".to_string(),
            PropertyDefinition {
                name: "text".to_string(),
                property_type: PropertyType::String,
                display_name: "text".to_string(),
                description: "Button text".to_string(),
                default_value: PropertyValue::String("Click me".to_string()),
                constraints: vec![],
                ui_hints: PropertyUIHints::default(),
                readonly: false,
                advanced: false,
            }
        );
        
        // enabled property
        properties.insert(
            "enabled".to_string(),
            PropertyDefinition {
                name: "enabled".to_string(),
                property_type: PropertyType::Boolean,
                display_name: "enabled".to_string(),
                description: "Whether the button is enabled".to_string(),
                default_value: PropertyValue::Boolean(true),
                constraints: vec![],
                ui_hints: PropertyUIHints::default(),
                readonly: false,
                advanced: false,
            }
        );
        
        // classes property
        properties.insert(
            "classes".to_string(),
            PropertyDefinition {
                name: "classes".to_string(),
                property_type: PropertyType::Array(Box::new(PropertyType::String)),
                display_name: "classes".to_string(),
                description: "Custom CSS classes".to_string(),
                default_value: PropertyValue::Array(vec![]),
                constraints: vec![],
                ui_hints: PropertyUIHints::default(),
                readonly: false,
                advanced: true,
            }
        );
        
        // font_size property
        properties.insert(
            "font_size".to_string(),
            PropertyDefinition {
                name: "font_size".to_string(),
                property_type: PropertyType::Integer,
                display_name: "font_size".to_string(),
                description: "Font size in pixels".to_string(),
                default_value: PropertyValue::Integer(16),
                constraints: vec![],
                ui_hints: PropertyUIHints::default(),
                readonly: false,
                advanced: false,
            }
        );
        
        let mut defaults = HashMap::new();
        defaults.insert("text".to_string(), PropertyValue::String("Click me".to_string()));
        defaults.insert("enabled".to_string(), PropertyValue::Boolean(true));
        defaults.insert("font_size".to_string(), PropertyValue::Integer(16));
        
        ComponentMetadata {
            component_type: "Button".to_string(),
            display_name: "Button".to_string(),
            description: "A clickable button component".to_string(),
            category: ComponentCategory::Input,
            version: "1.0.0".to_string(),
            schema: PropertySchema {
                properties,
                required: vec![],
                groups: vec![],
            },
            defaults,
            events: vec![],
            icon: None,
            tags: vec![],
        }
    }
    
    /// Register this component with the registry (this would be generated by derive macro)
    pub fn register(registry: &mut ComponentRegistry) {
        let metadata = Self::component_metadata();
        registry.register_component_metadata(metadata);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_button_metadata_generation() {
        let metadata = Button::component_metadata();
        
        // Test basic metadata
        assert_eq!(metadata.component_type, "Button");
        assert_eq!(metadata.display_name, "Button");
        assert_eq!(metadata.description, "A clickable button component");
        assert_eq!(metadata.category, ComponentCategory::Input);
        assert_eq!(metadata.version, "1.0.0");
        
        // Test properties
        assert_eq!(metadata.schema.properties.len(), 4);
        
        let text_prop = metadata.schema.properties.get("text").unwrap();
        assert_eq!(text_prop.property_type, PropertyType::String);
        assert_eq!(text_prop.default_value, PropertyValue::String("Click me".to_string()));
        assert!(!text_prop.advanced);
        
        let enabled_prop = metadata.schema.properties.get("enabled").unwrap();
        assert_eq!(enabled_prop.property_type, PropertyType::Boolean);
        assert_eq!(enabled_prop.default_value, PropertyValue::Boolean(true));
        
        let classes_prop = metadata.schema.properties.get("classes").unwrap();
        assert_eq!(classes_prop.property_type, PropertyType::Array(Box::new(PropertyType::String)));
        assert!(classes_prop.advanced);
        
        let font_size_prop = metadata.schema.properties.get("font_size").unwrap();
        assert_eq!(font_size_prop.property_type, PropertyType::Integer);
        assert_eq!(font_size_prop.default_value, PropertyValue::Integer(16));
        
        // Test defaults
        assert_eq!(metadata.defaults.len(), 3);
        assert_eq!(metadata.defaults.get("text"), Some(&PropertyValue::String("Click me".to_string())));
        assert_eq!(metadata.defaults.get("enabled"), Some(&PropertyValue::Boolean(true)));
        assert_eq!(metadata.defaults.get("font_size"), Some(&PropertyValue::Integer(16)));
    }
    
    #[test] 
    fn test_button_registration() {
        let mut registry = ComponentRegistry::new();
        
        // Register the button component
        Button::register(&mut registry);
        
        // Test that component was registered
        let metadata = registry.get_metadata("Button").unwrap();
        assert_eq!(metadata.component_type, "Button");
        
        let schema = registry.get_schema("Button").unwrap();
        assert_eq!(schema.properties.len(), 4);
    }
    
    #[test]
    fn test_macro_code_generation() {
        // Test the macro's token generation (this would normally be done at compile time)
        let tokens = generate_button_metadata();
        let token_string = tokens.to_string();
        
        // Check that the generated code contains expected elements
        assert!(token_string.contains("component_metadata"));
        assert!(token_string.contains("ComponentMetadata"));
        assert!(token_string.contains("PropertyDefinition"));
        
        // This is a basic smoke test - in practice the macro would be tested
        // through compilation and the resulting code functionality
    }
}